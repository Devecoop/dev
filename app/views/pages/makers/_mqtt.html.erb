<h2 id="mqtt-overview">Overview</h2>

<p>
  <a href="http://mqtt.org">MQTT</a>
  is a publish/subscribe, extremely simple and lightweight messaging protocol, designed for
  constrained devices and low-bandwidth, high-latency or unreliable networks.
</p>

<p>
  The Lelylan MQTT Broker is a simple way to interact with Lelylan directly from any
  MQTT client. It provides full API interaction, as well as push notifications and
  subscriptions. It gives you a MQTT 3.1 compliant solution supporting QoS 0 and QoS
  1 levels on message delivering.
</p>

<h2 id="mqtt-lelylan-setup">Lelylan Setup</a></h2>

<p>
  To connet your hardware with MQTT you first need to create a new device.
  Open <a href="http://lelylan.github.io/devices-dashboard-ng/">Lelylan Dashboard</a>
  and create a new device by following 3 simple steps (if you are new to Lelylan, you can
  <a href="http://people.lelylan.com/users/sign_up">sign up</a> for free).
</p>

<h3>1) Set a meaningful name (e.g. bedroom light).</h3>

<%= image_tag('makers-api/step-1.png', class: 'img-thumbnail') %>

<h3>2) Choose the device type (for this tutorial choose <em>Basic Light</em>).</h3>

<%= image_tag('makers-api/step-2.png', class: 'img-thumbnail') %>

<h3>3) Choose <em>"Connect with MQTT"</em> as connectivity option.</h3>

<%= image_tag('makers-api/step-3.png', class: 'img-thumbnail') %>

<h3>4) Get the Device ID and Device Secret.</h3>

<p>
  Once the device is created click on settings (placed under the device name)
  and get the device info.
</p>

<ul>
  <li><em>ID</em> - Unique device identifier (MQTT username).</li>
  <li><em>Secret</em> - Device secret code (MQTT password).</li>
  <li><em>Type</em> - Link to the type definition (use it to check the device properties)</li>
</ul>

<%= image_tag('makers-api/step-4.png', class: 'img-thumbnail') %>

<h2 id="mqtt-connecting-to-lelylan">Connecting to Lelylan</h2>

<p>
Lelylan MQTT accepts connections from any MQTT client supporting the MQTT 3.1 specs. During
the connection phase the client needs to set the device <code>id</code> as username and the
device <code>secret</code> as password. Once the connection is successful, you need to implement
two services.
</p>

<ul>
<li>One to receive data from Lelylan</li>
<li>One to send data to Lelylan</li>
</ul>

<h3>How to receive data</h3>

<p>
The MQTT client (hardware) receives all messages coming from Lelylan
(e.g API, dashboard) through the <code>devices/:id/get</code> topic. Every message is
made up from a list of properties with the following structure.
</p>

<table class="table table-stripped table-hover">
  <tbody>
    <tr>
      <td class="parameter">
        <span>properties</span>
      </td>
      <td>
        Array of properties (received from your hardware).
      </td>
    </tr>
    <tr>
      <td class="parameter nested">
        <span>&raquo; property.id</span>
      </td>
      <td>
        Property ID.
      </td>
    </tr>
    <tr>
      <td class="parameter nested">
        <span>&raquo; property.value</span>
      </td>
      <td>
        Property value.
      </td>
    </tr>
  </tbody>
</table>

<h3>How to send data</h3>

<p>
When a physical device updates its status through a physical interaction (e.g turn on a light
using the physical switch), Lelylan must be notified by publishing a message to the topic
<code>devices/:id/set</code> with the list of the updated properties.
Every sent message is made up from a list of properties with the following structure.
</p>

<table class="table table-stripped table-hover">
  <tbody>
    <tr>
      <td class="parameter">
        <span>properties</span>
        <span class="info">optional</span>
      </td>
      <td>
        Array of properties (sent from your hardware).
      </td>
    </tr>
    <tr>
      <td class="parameter nested">
        <span>&raquo; property.id</span>
        <span class="info">required</span>
      </td>
      <td>
        Property ID.
      </td>
    </tr>
    <tr>
      <td class="parameter nested">
        <span>&raquo; property.value</span>
        <span class="info">required</span>
      </td>
      <td>
        Desired property value.
        <a href="/support#faq-value-expected-pending">Learn more about</a>.
      </td>
    </tr>
        <tr>
      <td class="parameter nested">
        <span>&raquo; property.expected</span>
        <span class="info">optional</span>
      </td>
      <td>
        Expected property value.
        <a href="/support#faq-value-expected-pending">Learn more about</a>.
      </td>
    </tr>
        <tr>
      <td class="parameter nested">
        <span>&raquo; property.pending</span>
        <span class="info">optional</span>
      </td>
      <td>
        Property pending status.
        <a href="/support#faq-value-expected-pending">Learn more about</a>.
        <span class="info">Valid values: true, false.</span>
      </td>
    </tr>
  </tbody>
</table>


<h3>Async physical flow</h3>

<p>
When sending a message to the physical world, Lelylan expects a feedback to its requests.
For example if Lelylan sends a request to turn on a light, your hardware must send back a
confirmation to Lelylan saying that the light was turned on. Until the confirmation message
isn't sent back, the device lives in a <a href="/support#faq-value-expected-pending">pending</a>
status (in the dashboard you'll see a spinner).
</p>

<p>
To close the pending status and tell Lelylan that the requested changes were applied, the
physical device must publish a message to the out topic <code>/devices/:id/set</code>
confirming the updated property values.
</p>

<h2 id="mqtt-code-examples">Code Examples</h2>

<ul class="nav nav-tabs">
  <li class="active"><a href="#connect-physical-device-arduino" data-toggle="tab" class="arduino">Adruino</a></li>
  <li><a href="#connect-physical-device-node" data-toggle="tab" class="node">Node.js</a></li>
  <li><a href="#connect-physical-device-ruby" data-toggle="tab" class="ruby">Ruby</a></li>
  <li><a href="#connect-physical-device-python" data-toggle="tab" class="python">Python</a></li>
</ul>

<div class="tab-content">
  <div class="tab-pane active" id="connect-physical-device-arduino">
    <div class="preview">
      <pre class="prettyprint"><xmp>/* -------------------------------------------------------
 * Install https://github.com/andreareginato/pubsubclient
 * It sets the max packet size to 512 bytes.
 * ------------------------------------------------------- */

#include <SPI.h>
#include <Ethernet.h>
#include <PubSubClient.h>

// Update these with values suitable for your network.
byte mac[] = { 0xA0, 0xA0, 0xBA, 0xAC, 0xAE, 0x12 };

/* device credentials */
char* deviceId = "<DEVICE-ID>";         // set your device id (will be the MQTT client username)
char* deviceSecret = "<DEVICE-SECRET>"; // set your device secret (will be the MQTT client password)

/* device topics */
char* outTopic = "devices/<DEVICE-ID>/set"; // where physical updates are published
char* inTopic = "devices/<DEVICE-ID>/get";  // where lelylan updates are received

/* Access settings */
byte server[] = { 96, 126, 109, 170 }; // MQTT server address
char* clientId = "<CLIENT-ID>"; // MQTT client id (random, max 23 bytes)

/* sample payload published to lelylan */
/* (to get the desired property-id go to the device settings and click on the type link) */
char* payload = "{\"properties\":[{ \"id\": \"<PROPERTY-ID>\", \"value\": \"<VALUE>\" }]}";

/* Ethernet configuration */
byte mac[] = { 0xA0, 0xA0, 0xBA, 0xAC, 0xAE, 0x12 };
EthernetClient ethClient;

/* MQTT communication */
void callback(char* topic, byte* payload, unsigned int length); // subscription callback
PubSubClient client(server, 1883, callback, ethClient);         // mqtt client

/* arduino setup */
void setup() {
  Serial.begin(9600);
  delay(500);

  Ethernet.begin(mac);
  Serial.print("Connected with IP: ");
  Serial.println(Ethernet.localIP());

  lelylanConnection(); // MQTT server connection
}

/* arduino loop */
void loop() {
  lelylanConnection();
}

/* MQTT server connection */
void lelylanConnection() {
  // add reconnection logics
  if (!client.connected()) {
    // connection to MQTT server
    if (client.connect(clientId, deviceId, deviceSecret)) {
      Serial.print("[OK] Connected with MQTT");
      lelylanSubscribe();  // topic subscription
      lelylanPublish();    // topic publishing
    }
  }

  client.loop();
}

/* MQTT publish */
void lelylanPublish() {
  client.publish(outTopic, payload);
}

/* MQTT subscribe */
void lelylanSubscribe() {
  client.subscribe(inTopic);
}

// debug to show the received message
void callback(char* topic, byte* payload, unsigned int length) {
  Serial.print("Receiving subscribed message");
  Serial.println(topic);
  Serial.write(payload, length);
}</xmp></pre>
  </div>
</div>
<div class="tab-pane" id="connect-physical-device-node">
  <div class="preview">
    <pre class="prettyprint"><xmp>// ------------------------------
// Install first the mqtt client
// $ npm install mqtt
// ------------------------------

// device credentials
var device = { id: '<device-id>', secret: '<device-secret>' }

// device topics
var in_topic  = 'devices/' + device.id + '/get'   // receiving messages
  , out_topic = 'devices/' + device.id + '/set';  // publishing messages

// connection settings
var mqtt = require('mqtt')
  , host = '96.126.109.170'
  , port = '1883'

// client settings
var settings = {
  username: device.id,     // device.id as client username
  password: device.secret  // device.secret as client password
}

// client connection
var client = mqtt.createClient(port, host, settings);
client.on('connect', function() {
  console.log('Client successfully connected');

  // subscribe for incoming messages
  client.subscribe(in_topic);
  client.on('message', function(topic, message) {
    console.log('received', topic, message);
  });

  // publish a message
  var payload = { properties: [{ id: '<property-id>', value: '<value>' }] };
  client.publish(out_topic, JSON.stringify(payload));
});</xmp></pre>
  </div>
</div>
<div class="tab-pane" id="connect-physical-device-ruby">
  <div class="preview">
    <pre class="prettyprint"><xmp># ------------------------------
# Install first the mqtt client
# $ gem install mqtt
# ------------------------------

require 'mqtt'
require 'uri'
require 'json'

# device credentials
device = { id: '<device-id>', secret: '<device-secret>' }

# device topics
in_topic  = 'devices/' + device[:id] + '/get' # receiving messages
out_topic = 'devices/' + device[:id] + '/set' # published messages

# connection parameters
settings = {
  remote_host: '96.126.109.170',
  remote_port: '1883',
  username: device[:id],
  password: device[:secret]
}

# client connection
MQTT::Client.connect(settings) do |client|
  Thread.new do
    # subscribe for incoming messages
    client.get(in_topic) do |topic, message|
      puts "Received #{topic}: #{message}"
    end
  end

  # publish a message
  payload = { properties: [{ id: '<property-id>', value: '<value>' }] };
  client.publish(out_topic, payload.to_json)
  puts "Published #{out_topic}: #{payload}"
  loop { sleep 0.1 } # keep listening
end</xmp></pre>
  </div>
</div>
<div class="tab-pane" id="connect-physical-device-python">
  <div class="preview">
    <pre class="prettyprint"><xmp># --------------------------
# Install first mosquitto
# $ pip install mosquitto
# --------------------------

import mosquitto, json

# event callbacks
def on_connect(mosq, obj, rc):
    print("rc: " + str(rc))

def on_message(mosq, obj, msg):
    print(msg.topic + " " + str(msg.qos) + " " + str(msg.payload))

def on_publish(mosq, obj, mid):
    print("mid: " + str(mid))

def on_subscribe(mosq, obj, mid, granted_qos):
    print("Subscribed: " + str(mid) + " " + str(granted_qos))

# create client
client = mosquitto.Mosquitto()

# assign event callbacks
client.on_message = on_message
client.on_connect = on_connect
client.on_publish = on_publish
client.on_subscribe = on_subscribe

# device credentials
device_id     = '<device-id>'
device_secret = '<device-secret>'

# device topics
in_topic  = 'devices/' + device_id + '/get'  # receiving messages
out_topic = 'devices/' + device_id + '/set'  # publishing messages

# client connection
client.username_pw_set(device_id, device_secret)
client.connect('96.126.109.170', '1883')

# subscribe (with QoS level 0)
client.subscribe(in_topic, 0)

# publish a message
payload = { 'properties': [{ 'id': '<property-id>', 'value': '<value>' }] };
client.publish(out_topic, json.dumps(payload))

# Continue the network loop, exit when an error occurs
rc = 0
while rc == 0:
    rc = client.loop()
print("rc: " + str(rc))</xmp></pre>
    </div>
  </div>
</div>

<h2 id="mqtt-control-your-physical-device">Control your physical device</h2>

<p>
Access <a href="http://lelylan.github.io/devices-dashboard-ng">Lelylan Dashboard</a>
and control your connected device from mobile, tablet and desktop in realtime.
If any problem occurs, let <a href="http://twitter.com/lelylan">@lelylan</a> know.
</p>

<a href="http://lelylan.github.io/devices-dashboard-ng/">
<%= image_tag('makers-api/control.png', class: 'img-thumbnail') %>
</a>

<h2 id="mqtt-learn-more">Learn more</h2>

<p>
In this section we described how MQTT works with Lelylan.
If you want to learn more check out the hardware tutorials
in the <a href="/#makers">getting started</a> section. Each of them deeply describe how the
MQTT client communicate with Lelylan (using different hardware platforms).
</p>
<br>

<h2 id="mqtt-feedback"><span class="glyphicon glyphicon-comment"></span> Feedback</h2>

<%= render 'shared/feedback' %>
