<article>

<aside class="menu">
</br>
<table>
  <tbody>
    <tr><td><a href="" class="upcase"><%= title %></a></td></tr>
    <tr><td>&raquo; <a href="#response-formats">Response formats</a></td></tr>
    <tr><td>&raquo; <a href="#cors">CORS</a></td></tr>
    <tr><td>&raquo; <a href="#public-resources">Public resources</a></td></tr>
    <tr><td>&raquo; <a href="#pagination">Infinite scrolling pagination</a></td></tr>
    <tr><td>&raquo; <a href="#time-formats">Accepted time formats</a></td></tr>
    <tr><td>&raquo; <a href="#errors">Errors response</a></td></tr>
    <tr><td>&raquo; <a href="#rate-limit">Rate limit</a></td></tr>
    <tr><td>&raquo; <a href="#http-caching">HTTP caching</a></td></tr>
    <tr><td>&raquo; <a href="#verbs">HTTP verbs limitations</a></td></tr>
    <tr><td>&raquo; <a href="#user-profile">User profile</a></td></tr>
    <tr><td>&raquo; <a href="#rest">REST interface</a></td></tr>
  </tbody>
</table>
</aside>

</article>

<article>

<h1 class="call"><a name="response-formats">Response formats</a></h1>

<p>
  Lelylan responds only with JSON representations.
</p>

<br/>

<table class="zebra-striped">
  <thead>
    <tr>
      <td><strong>Format</strong></td>
      <td><strong>Suffix</strong></td>
      <td><strong>Content-Type</strong></td>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>JSON</td>
      <td>.json</td>
      <td>application/json</td>
    </tr>
  </tbody>
</table>

</article>

<br/>

<article>

<h1 class="call"><a name="cors">CORS</a></h1>

<p>
  Lelylan supports <a href="http://www.html5rocks.com/en/tutorials/cors/">CORS</a>
  (Cross Origin Resource Sharing) for AJAX requests. CORS allows cross-domain communication
  from the browser. By building on top of the XmlHttpRequest object, CORS allows developers
  to work with the same idioms as same-domain requests. Here a complete list of
  <a href="http://caniuse.com/cors">browsers supporting CORS</a>.
</p>

<p>
  Lelylan does not support JSON-P as CORS is a more complete solution. If you think
  JSON-P must be implemented <a href="/community/support/">write us</a>.
</p>

</article>

<br/>

<article>

<h1 class="call"><a name="public-resources">Public resources</a></h1>

<p>
  Public resources are resources that don't need <a href="/api/oauth/#api-requests">authentication</a>.
</p>


<table class="zebra-striped" style="width:500px;">
  <thead>
    <tr>
      <th>SERVICE DESCRIPTION</th>
      <th>DOCUMENTATION</th>
    </tr>
  </thead>
  <tbody>
  <tr>
    <td style="width:200px">Get all public types</td>
    <td><a href="/api/types/#get-all-types">GET /types/public</a></td>
  </tr>
  <tr>
    <td>Get a type</td>
    <td><a href="/api/types/#get-a-type">GET /types/:id</a></td>
  </tr>
  <tr>
    <td>Get all public properties</td>
    <td><a href="/api/types/properties/#get-all-properties">GET /properties/public</a></td>
  </tr>
  <tr>
    <td>Get a property</td>
    <td><a href="/api/types/properties/#get-a-property">GET /properties/:id</a></td>
  </tr>
  <tr>
    <td>Get all public functions</td>
    <td><a href="/api/types/functions/#get-all-functions">GET /functions/public</a></td>
  </tr>
  <tr>
    <td>Get a function</td>
    <td><a href="/api/types/functions/#get-a-function">GET /functions/:id</a></td>
  </tr>
  <tr>
    <td>Get all public statuses</td>
    <td><a href="/api/types/statuses/#get-all-statuses">GET /statuses/public</a></td>
  </tr>
  <tr>
    <td>Get a status</td>
    <td><a href="/api/types/statuses/#get-a-status">GET /statuses/:id</a></td>
  </tr>
</table>

</article>

<br/>

<article>

<h1 class="call"><a name="pagination">Infinite scrolling pagination</a></h1>

<p>
  Sometimes your database will be so large that it's impossible to pre-load it client-side. The solution is to pre-load a segment of the database and then use
  pagination to load more data. Pagination is better with an infinite
  scrolling pattern, rather than showing a list of pages.
  When fetching the next page set the parameter <code>start</code>
  with the last fetched resource <code>URI</code>.
</p>

<div class="preview"><pre><code class="no-highlight">curl -L http://api.lelylan.com/devices.json?
start=http://api.lelylan.com/devices/4dcb9ea9000d</code></pre>
</code></pre></div>

<p>
The default number of resources per page is 25 and the maximum is 100.
</p>
</article>

<br/>

<article>

<h1 class="call"><a name="time-formats">Accepted time formats</a></h1>

<p>
The preferred time format accepted from time attributes is
<a href="http://en.wikipedia.org/wiki/ISO_8601">ISO 8601</a> (for more accepted
formats check out the <a href="http://ruby-doc.org/core-1.9.3/Time.html">Ruby Time Class</a>).
The following examples describe the same time using two different accepted formats.
</p>

<div class="preview">
  <pre><code class="no-highlight">2012-07-03 12:45:29Z        # ISO 8601
2012-07-03 14:45:29 +0200   # UTC local time with offset "+hh:mm"</code></pre>
</div>
</article>

<br/>

<article>

<h1 class="call"><a name="errors">Error responses</a></h1>

<h2><a name="401">401 - Unauthorized</a></h2>

<div class="preview unified"><pre><code class="no-highlight">HTTP/1.1 401 Unauthorized</code></pre></div>

<div class="preview"><pre><code>{
  "status": 401,
  "method": "POST",
  "request": "http://api.lelylan.com/devices/4f4bb686d033a957c1000251",
  "error": {
    "code": "notifications.access.not_authorized",
    "description": "Token not valid"
  }
}</code></pre></div>

<h2><a name="404">404 - Not Found</a></h2>

<div class="preview unified"><pre><code class="no-highlight">HTTP/1.1 404 Not Found</code></pre></div>

<div class="preview"><pre><code>{
  "status": 404,
  "method": "GET",
  "request": "http://api.lelylan.com/devices/4f4ba959d033a95549000261",
  "error": {
    "code": "notifications.resource.not_found",
    "description": "Resource not found",
    "uri": "http://api.lelylan.com/devices/4f4ba959d033a95549000261"
  }
}</code></pre></div>

<h2><a name="422">422 - Not Valid</a></h2>

<div class="preview unified"><pre><code class="no-highlight">HTTP/1.1 422 Not Valid</code></pre></div>

<div class="preview"><pre><code>{
  "status": 422,
  "method": "POST",
  "request": "http://api.lelylan.com/devices",
  "error": {
    "code": "notifications.resource.not_valid",
    "description": "Name can't be blank.",
    "body": { "name": "" },
  }
}</code></pre></div>

</article>

<br/>

<article>

<h1 class="call"><a name="rate-limit">Rate limit</a>
</h1>

<p>
We limit requests to <strong>5000</strong> per day. You can check the returned HTTP headers
of any authenticated API request to see your current status.
</p>

<div class="preview"><pre><code>HTTP/1.1 200 OK
X-RateLimit-Limit: 5000
X-RateLimit-Remaining: 4999</code></pre></div>

<p>
When you exceed the API calls limit your request is forbidden.
</p>

<div class="preview unified"><pre><code>HTTP/1.1 403 Forbidden
X-RateLimit-Limit: 5000
X-RateLimit-Remaining: 0</code></pre></div>

<div class="preview"><pre><code>{
  "status": 403,
  "method": "POST",
  "request": "http://api.lelylan.com/devices",
  "error": {
    "code": "notifications.access.rate_limit",
    "description": "Rate limit exceeded",
    "daily_rate_limit": 5000,
  }
}</code></pre></div>

<p>
Please <a href="mailto:touch@lelylan.com">contact us</a> to request white listed access for
your application.
</p>

</article>

<br/>

<article>

<h1 class="call"><a name="http-caching">HTTP caching</a></h1>

<p>
HTTP caching is a universally adopted specification across all modern web
browsers. Appropriate use of these standards let you improve response times
and reduce server load. At Lelylan we focus on conditional requests.
</p>

<p>
When a conditional requests is made across the network, unmodified resources result
in an empty response body, aka 304 Not Modified, saving the cost of transferring the
resource back to the end client. To make this possible Lelylan returns the
<code>Etag</code> and <code>Last-Modified</code> headers.
</p>

<div class="preview"><pre><code>Etag: "e59b3c1fca50b5d0bf44c931253ded86"
Last-Modified: Sat, 01 Sep 2012 16:00:32 GMT</code></pre></div>

<p>
Learn more about
<a href="https://devcenter.heroku.com/articles/increasing-application-performance-with-http-cache-headers#conditional-requests">
conditional requests</a> to make your app faster.
</p>

</article>

<br/>

<article>

<h1 class="call"><a name="verbs">HTTP verbs limitations</a></h1>

<p>
Not all HTTP clients are able to make PUT or DELETE requests (e.g. web browsers).
In order to work around this limitation, it is possible to send a POST request
with a <code>_method</code> parameter set to <code>put</code> or <code>delete</code>.
</p>

</article>

<br/>

<article>

<h1 class="call"><a name="user-profile">User profile</a></h1>

<p>
Returns extended information for the authenticated user.
</p>

<h4>Example Request</h4>

<ul class="nav nav-tabs">
  <li class="active"><a href="#get-a-user-curl" data-toggle="tab" class="curl">Curl</a></li>
  <li><a href="#get-a-user-node" data-toggle="tab" class="node">Node.js</a></li>
  <li><a href="#get-a-user-javascript" data-toggle="tab" class="javascript">Javascript</a></li>
  <li><a href="#get-a-user-ruby" data-toggle="tab" class="ruby">Ruby</a></li>
</ul>

<div class="tab-content">
  <div class="tab-pane active" id="get-a-user-curl">
    <div class="preview">
      <pre><code class="no-highlight">curl http://api.lelylan.com/me \
    -H 'Authorization: Bearer &lt;token&gt;'</code></pre>
    </div>
  </div>
  <div class="tab-pane" id="get-a-user-node">
    <div class="preview">
      <pre><code class="javascript">var Lelylan = require('lelylan-node')({ token: token });
Lelylan.Profile.me(callback);</code></pre>
    </div>
  </div>
  <div class="tab-pane" id="get-a-user-javascript">
    <div class="preview">
      <pre><code># todo</code></pre>
    </div>
  </div>
  <div class="tab-pane" id="get-a-user-ruby">
    <div class="preview">
      <pre><code># todo</code></pre>
    </div>
  </div>
</div>

<h4>Example header response</h4>

<div class="preview"><pre><code class="no-highlight">HTTP/1.1 200 OK</code></pre></div>

<h4 id="device-representation">Example body response</h4>

<div class="preview"><pre><code>{
  "id": "5036227a4f1b030200009000",
  "email": "reggie@lelylan.com",
  "full_name": "Reggie",
  "homepage": "http://lelylan.com",
  "location": "New York",
  "rate_limit": 5000
}</code></pre></div>

</article>

<br/>

<article>

<h1 class="call"><a name="rest">REST interface</a></h1>

<p>
Lelylan API attempts to conform to the design principles of Representational
State Transfer (REST). The basic idea is to define services that look like the
web, through the definition and the representation of all the resources that interact
with the house. If you are thinking about what a resource is, think at it as
anything important enough to be referenced as a thing by itself. That said,
following the REST Architecture, Lelylan defined its API following these rules.
</p>

<ul>
  <li><strong>Connectedness</strong> - You can move between resources using the links contained in them.</li>
  <li><strong>Addressability</strong> - Every resource is identified from an address.</li>
  <li><strong>Uniform interface</strong> - The HTTP verb is used to define the action to apply.</li>
</ul>

<p>
To understand how REST really works we highly suggest you to read
<a href="http://www.amazon.com/RESTful-Web-Services-Leonard-Richardson/dp/0596529260/">Restful Web Services</a>

</article>

