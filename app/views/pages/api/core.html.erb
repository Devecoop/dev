<article>

<aside class="menu">
</br>
<table>
  <tbody>
    <tr><td>&raquo; <a href="#resources">Devices, types and locations</a></td></tr>
    <tr><td>&raquo; <a href="#response-formats">Response formats</a></td></tr>
    <tr><td>&raquo; <a href="#public-resources">Public resources</a></td></tr>
    <tr><td>&raquo; <a href="#pagination">Infinite scrolling pagination</a></td></tr>
    <tr><td>&raquo; <a href="#time-formats">Accepted time formats</a></td></tr>
    <tr><td>&raquo; <a href="#errors">Errors response</a></td></tr>
    <tr><td>&raquo; <a href="#rate-limit">Rate limit</a></td></tr>
    <tr><td>&raquo; <a href="#verbs">HTTP verbs limitations</a></td></tr>
    <tr><td>&raquo; <a href="#rest">REST interface</a></td></tr>
  </tbody>
</table>
</aside>

<h1 class="call"><a name="resources">Devices, types and locations</a></h1>

<p>
  Lelylan REST API is made up from four logical blocks.
</p>

<ul>
  <li><a href="/api/devices/">Devices</a> - Defines a set of services 
    to create, monitor and control devices.</li>
  <li><a href="/api/types/">Types</a> - Defines a set of services to 
    describe the structure of a device.</li>
  <li><a href="/api/locations/">Locations</a> - Defines a set of services 
    to describe the places we live in.</li>
  <li><a href="/api/physicals/">Physical Devices</a> - Defines a set of services 
    to connect Lelylan to your physical devices.</li>
</ul>

</article>

<br/>

<article>

<h1 class="call"><a name="response-formats">Response formats</a></h1>

<p>
  Right now Lelylan returns only JSON. To define the format you can set the URI suffix 
  or the Content-Type header.
</p>

<br/>

<table class="zebra-striped">
  <thead>
    <tr>
      <td><strong>Format</strong></td>
      <td><strong>Suffix</strong></td>
      <td><strong>Content-Type</strong></td>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>JSON</td>
      <td>.json</td>
      <td>application/json</td>
    </tr>
  </tbody>
</table>

<p>
  To enable cross site requests we offer JSONP. To use it add <code>callback=method</code>
  parameter to your request and Lelylan will respond with <code>method(json-representation)</code>. 
  In this case the returned Content-Type is <code>application/javascript</code>.
</p>
</article>

<br/>

<article>

<h1 class="call"><a name="public-resources">Public resources</a></h1>

<p>
  Public resources are resources that don't need <a href="/api/oauth/#api-requests">authentication</a>.
</p>


<table class="zebra-striped" style="width:400px;">
  <thead>
    <tr>
      <th>PUBLIC SERVICE</th>
      <th>DOCUMENTATION</th>
    </tr>
  </thead>
  <tbody>
  <tr>
    <td style="width:150px">Get all public types</td>
    <td><a href="/api/types/#get-all-types">GET /types/public</a></td>
  </tr>
  <tr>
    <td>Get a type</td>
    <td><a href="/api/types/#get-a-type">GET /types/:id</a></td>
  </tr>
  <tr>
    <td>Get all public properties</td>
    <td><a href="/api/types/properties/#get-all-properties">GET /properties/public</a></td>
  </tr>
  <tr>
    <td>Get a property</td>
    <td><a href="/api/types/properties/#get-a-property">GET /properties/:id</a></td>
  </tr>
  <tr>
    <td>Get all public functions</td>
    <td><a href="/api/types/functions/#get-all-functions">GET /functions/public</a></td>
  </tr>
  <tr>
    <td>Get a function</td>
    <td><a href="/api/types/functions/#get-a-function">GET /functions/:id</a></td>
  </tr>
  <tr>
    <td>Get all public statuses</td>
    <td><a href="/api/types/statuses/#get-all-statuses">GET /statuses/public</a></td>
  </tr>
  <tr>
    <td>Get a status</td>
    <td><a href="/api/types/statuses/#get-a-status">GET /statuses/:id</a></td>
  </tr>
</table>

</article>

<br/>

<article>

<h1 class="call"><a name="pagination">Infinite scrolling pagination</a></h1>

<p>
  Sometimes your database will be so large that it's impossible to pre-load it all 
  client-side. The solution is to pre-load a segment of the database and then use 
  pagination to load more data. Pagination is best done with an infinite 
  scrolling pattern, rather than showing a list of pages. 
  When fetching the next page set the parameter <code>from</code> 
  with the last fetched resource <code>URI</code>.
</p>

<div class="preview"><pre><code class="no-highlight">curl -L https://api.lelylan.com/devices.json?
start=https://api.lelylan.com/devices/4dcb9ea9000d</code></pre>
</code></pre></div>

<p>
In this example we fetch the 25 devices after the one with id 4dcb9ea9000d.
The default number of resources per page is 25 and the maximum is 100.
</p>
</article>

<br/>

<article>

<h1 class="call"><a name="time-formats">Accepted time formats</a></h1>

<p>
The preferred time format accepted from time attributes is
<a href="http://en.wikipedia.org/wiki/ISO_8601">ISO 8601</a>. For more accepted
formats check out the
<a href="http://ruby-doc.org/core-1.9.3/Time.html">Ruby Time Class</a>.
</p>

<p>
The following example describe the same time in two different accepted formats.
</p>

<div class="preview">
  <pre><code class="no-highlight">2011-07-03 12:45:29Z        # ISO 8601
2011-07-03 14:45:29 +0200   # UTC local time with offset "+hh:mm"</code></pre>
</div>
</article>

<br/>

<article>

<h1 class="call"><a name="errors">Errors response</a></h1>

<h2><a name="401">401 - Unauthorized</a></h2>

<div class="preview unified"><pre><code class="no-highlight">HTTP/1.1 401 Unauthorized</code></pre></div>

<div class="preview"><pre><code>{ 
  "status": "401",
  "method": "POST",
  "request": "http://api.lelylan.com/devices/4f4bb686d033a957c1000251",
  "error": {
  "code": "notifications.access.not_authorized",
  "description": "Token not valid"
  }
}</code></pre></div>

<h2><a name="404">404 - Not Found</a></h2>

<div class="preview unified"><pre><code class="no-highlight">HTTP/1.1 404 Not Found</code></pre></div>

<div class="preview"><pre><code>{ 
  "status": "404",
  "method": "GET",
  "request": "https://api.lelylan.com/devices/4f4ba959d033a95549000261",
  "error": {
  "code": "notifications.resource.not_found",
  "description": "Resource not found",
  "uri": "https://api.lelylan.com/devices/4f4ba959d033a95549000261"
  }
}</code></pre></div>

<h2><a name="422">422 - Not Valid</a></h2>

<div class="preview unified"><pre><code class="no-highlight">HTTP/1.1 422 Not Valid</code></pre></div>

<div class="preview"><pre><code>{
  "status": "422",
  "method": "POST",
  "request": "https://api.lelylan.com/devices",
  "error": {
  "code": "notifications.resource.not_valid",
  "description": "Name can't be blank.",
  "body": { "name": "" },
  }
}</code></pre></div>

</article>

<br/>

<article>

<h1 class="call"><a name="rate-limit">Rate limit</a></h1>

<p>
<span class="label">todo</span></br>
The default rate limit for calls to the REST API varies depending on the authorization 
method being used and whether the method itself requires authentication. Unauthenticated 
calls are permitted <strong>100</strong> requests per hour. Unauthenticated calls are measured against 
the public facing IP of the server or device making the request. With OAuth2 are 
permitted <strong>300</strong> requests per hour and they are measured against the 
OAuth2 token used in the request.
</p>

</article>

<br/>

<article>

<h1 class="call"><a name="verbs">HTTP verbs limitations</a></h1>

<p>
Not all HTTP clients are able to make PUT or DELETE requests (e.g. web browsers). 
In order to work around this limitation, it is possible to send a POST request 
with a <code>_method</code> parameter set to <code>put</code> or <code>delete</code>.
</p>
</article>

<br/>

<article>

<h1 class="call"><a name="rest">REST interface</a></h1>

<p>
Lelylan API attempts to conform to the design principles of Representational 
State Transfer (REST). The basic idea is to define services that look like the 
web, through the definition and the representation of all resources that interact 
with the house. If you are thinking at what is a resource is, think at it as 
anything important enough to be referenced as a thing in itself. That said, 
following the REST Architecture, Lelylan have defined its API following these rules.
</p>

<ul>
  <li><strong>Connectedness</strong> - You can move between resources using the links contained in them.</li>
  <li><strong>Addressability</strong> - Every resource is identified from an address.</li>
  <li><strong>Uniform interface</strong> - The HTTP verb is used to define the action to apply.</li>
</ul>

<p>
To understand how REST really work we highly suggest you to read
<a href="http://www.amazon.com/RESTful-Web-Services-Leonard-Richardson/dp/0596529260/">Restful Web Services</a>
</article>

<br/>

